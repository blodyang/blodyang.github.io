{"pages":[{"title":"Categories","date":"2020-07-31T18:41:05.836Z","path":"categories/index.html","text":""},{"title":"About","date":"2020-07-31T18:41:05.830Z","path":"about/index.html","text":""},{"title":"Tags","date":"2020-07-31T18:41:05.843Z","path":"tags/index.html","text":""}],"posts":[{"title":"MVVM","date":"2020-08-21T02:47:35.000Z","path":"wiki/MVVM/","text":"对MVVM的理解MVVM分为Model、View、ViewModel三者 Model：代表数据模型，数据和业务逻辑都在Model层中定义 View：代表UI视图，负责数据的展示 ViewModel：就是与界面(view)对应的Model。因为，数据库结构往往是不能直接跟界面控件一一对应上的，所以，需要再定义一个数据对象专门对应view上的控件。而ViewModel的职责就是把model对象封装成可以显示和接受输入的界面数据对象 12Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。 ViewModel就是View与Model的连接器，View与Model通过ViewModel实现双向绑定Model代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑View 代表UI 组件，它负责将数据模型转化成UI 展现出来。ViewModel 监听模型数据的改变和控制视图行为、处理用户交互，简单理解就是一个同步View 和 Model的对象，连接Model和View。在MVVM架构下，View 和 Model 之间并没有直接的联系，而是通过ViewModel进行交互，Model 和 ViewModel 之间的交互是双向的， 因此View 数据的变化会同步到Model中，而Model 数据的变化也会立即反应到View 上。ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作DOM, 不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。","tags":[{"name":"mvvm","slug":"mvvm","permalink":"http://yoursite.com/tags/mvvm/"}],"categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}]},{"title":"promise","date":"2020-08-21T02:08:35.000Z","path":"wiki/promise/","text":"基本介绍 异步promisePromise是ES6中新增的构造器。它主要用来优化实现异步操作的另一种方式。 1234// nodjs文件读写fs.readFile(路径，utf8,(err,data)=&gt;&#123;&#125;) promise构造器Promise是一个构造器，用来创建Promise类型的对象 。就好像Array是一个构造器，用来创建数组 格式 1234 var p = new Promise((ok,err)=&gt;&#123; //某个条件下，执行ok()// 某个条件下，执行err&#125;) 参考资料","tags":[{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"}],"categories":[{"name":"promise","slug":"promise","permalink":"http://yoursite.com/categories/promise/"}]},{"title":"跨域","date":"2020-08-20T08:47:29.000Z","path":"wiki/跨域/","text":"跨域 不同域名 不同端口 不同协议 不同域名 proxy 代理 jsonp 后端配置(常用) 优化123456789101112131415161718192021222324251、加载优化 静态资源加载优化，cdn or oss 尽可能少的加载外联css、js代码，html头部，增加dsn-preftch，减少dns解析时间 压缩css js pic，减小体积，服务端开启gzip压缩 控制http请求 js加载脚本阻塞浏览器主线程，考虑异步， 如 async 利用好缓存，利用好http响应头缓存字段，开启静态资源缓存2、浏览器渲染 css层不要太深，避免最内层使用统配选择器 js脚本不要太复杂，减少js解析时间，少引用复杂的第三方脚本 模块按需加载，按需打包，首页仅仅加载和执行和首屏相关的脚本，其他脚本延迟加载 第三方包需不需 要精简 打包优化，code split webpack3，缓存 内存 响应资源放入内存，直接读取，无需线程转换， 消耗资源 客户端缓存 HTTp缓存 catche-control与服务器进行数据协商，根据标准缓存活着更新资源 网络相关的缓存 一般指dns解析结果的缓存或者预连接缓存，创建一个https成本很大 cdn 根据用户ip地址及请求的url选择一台距离用户比较近的资源缩短路径，提升性能 localstorage缓存html文档首次访问页面时，js执行完后会生成完整的html文档，缓存到localstorage里面 浏览器js占用大量时间LINUX命令将一个文件夹里面的所有文件复制到指定文件里 cp -r &#x2F;root&#x2F;XXX&#x2F;Account&#x2F;. &#x2F;ftp&#x2F;ZJNX 参考资料","tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"}],"categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}]},{"title":"闭包","date":"2020-08-20T08:45:50.000Z","path":"wiki/闭包/","text":"闭包的作用 一个函数可以访问外部函数的内部变量，构成一个闭包环境(函数嵌套 引用外部函数变量， 内部函数有一个对象，存储外部被引用的变量)12闭包的生命周期：在嵌套的内部函数成为垃圾对象时也就是不再被引用 12345闭包作用1. 变量维持的内存中2. 保护内部变量，以防造成污染 - 但是会造成内存泄露 1234使用场景---自定义js模块 开发中经常用到的函数，格式化时间日期的，判断是否是数字的等等，封装到一个模块里面， 在需要使用的地方引入。不能直接访问内部的东西，但是可以通过暴露接口给外部，操作内部的数据 123456789101112131415161718192021&lt;script&gt; function fun(n, o) &#123; console.log(o); return &#123; fun:function(m) &#123; return fun(m, n); &#125; &#125; &#125; // var b = fun(0).fun(1).fun(2).fun(3); //0 1 2 // m1no n 1 o 0 m 2 n 1 n 2 o 1 m 3 n 2 n 3 o 2 // var a = fun(0); // a.fun(1);//m 1 n 0 // a.fun(2); // m2 n 0 // a.fun(3); //m 3 n 0 var c = fun(0).fun(1); // m 1 n 0 n 1 o 0 c.fun(2); // m 2 n 1 n 2 o 1 c.fun(3); // m 3 n 1 n 3 o 1 闭包的缺点123函数执行完后，函数内部局部变量没有释放，占用内存时间会边长容易造成内存泄露***解决---及时释放内存结束生命&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; f&#x3D;null 闭包的暴力理解12345678910在使用闭包时候，当函数执行完，用一个新的引入变量，去接受内部函数返回的函数对象，闭包就在函数对象里面形成了， 作用就是 延长了外部函数变量的生命周期，以及内部函数对象的生命周期。如果没有引入变量是不会占用内存的，产生了 又放走了。结合截屏 看。。。对象的引用+垃圾回收机制函数在 那个对象里面调用，this就指向那个对象。 参考资料","tags":[{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"}],"categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}]},{"title":"js的数据类型","date":"2020-08-20T06:02:09.000Z","path":"wiki/js的数据类型/","text":"### ES 6为止,7种类型 1234567数值（number）：整数和小数（比如1和2.2）字符串（string）：文本（比如Everybody Loves Eileen）。布尔值（boolean）：表示真伪的两个特殊值，即true（真）和false（假）undefined：表示“未定义”或不存在，即由于目前没有定义，所以此处暂时没有任何值null：表示空值，即此处的值为空对象（object）：各种值组成的集合Symbol：独一无二的值，可以保证不会与其他属性名产生冲突 ### 内置的类型识别方法 123typeof 运算符instanceof 运算符Object.prototype.toString.call() 参考资料","tags":[],"categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}]},{"title":"js基础","date":"2020-08-03T10:28:22.000Z","path":"wiki/js/","text":"js创建对象的方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849501. 通过构造函数obj来创建var obj = new object();obj.name = &quot;xm&quot;;obj.age = 19;obj.eat = function()&#123;&#125;2. 字面量创建var obj =&#123; name: &quot; xm&quot;, age: 19, eat: function()&#123;&#125;&#125;3.工厂函数function students(name,age)&#123; var obj =&#123; name: &quot; xm&quot;, age: 19, eat: function()&#123;&#125; &#125;return obj;&#125;var xm = student(&quot;xm&quot;,19);var xh = student(&quot;xh&quot;,19);4. 自定义构造函数创建function students(name,age)&#123; this.name = name; this.age = age;&#125;var xm = new student(&quot;xm&quot;,19); js 对象继承1231.js原型（prototype）实现继承2.构造函数实现继承3.call , apply实现继承 参考资料 阅读更多 more","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"}],"categories":[{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"}]},{"title":"vue","date":"2020-08-02T08:58:18.670Z","path":"wiki/vue/","text":"v-if v-show区别1234567v-if更高的切换开销，v-show更高的渲染开销，频繁切换 v-show比较好，运行时条件不太可能改变 v-if比较好v-if监听组件的销毁与创建 v-if惰性，初始条件为假，什么也不做，只到条件第一次为真时候，才会开始条件渲染v-show 不管初始条件是什么，元素总是被渲染，并且只是简单的基于css进行切换 Vue生命周期12345678910111213（2+） beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed -----使用了 keep-alive 就会多2个生命周期： activated deactivated 二、生命周期的理解 总共分为：8个阶段 创建前&#x2F;后： beforeCreate ：vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。 created ： vue实例的数据对象data有了，但是$el还是没有 载入前&#x2F;后 beforeMount : vue实例的$el和data都初始化了,但还是挂载之前为虚拟dom节点，data.msg还未替换。 mounted : vue实例挂载完成,data.msg成功渲染的 更新前&#x2F;后 当data变化时，会触发：beforeUpdate、updated 销毁前&#x2F;后 当销毁的时候，会触发： beforeDestroy、destroyed 三、DOM 渲染在哪个周期中就已经完成 ： mounted 组件传值123父传子 props字传父 $emit传递一个事件，父组件监听事件兄弟传值 bus传值 $emit触发 $on监听 keep-alive1234567是什么？ 内置组件，能在组件切换过程中将状态保存在内存中，防止重复渲染dom说明：keep-alive不会再dom树中渲染 Vue 中的data为什么必须是一个函数12345678Vue 组件 data 为什么必须是函数 不用脚手架 vue.js new Vue(&#123; el:&quot;#app&quot;, template:xxx data: &#123; &#125; &#125;) 脚手架 组件 data 为什么必须是函数? 因为 JS 本身的特性带来的， 如果 data 是一个对象，那么由于对象本身属于引用类型， 当我们修改其中的一个属性时， 会影响到所有 Vue 实例的数据。如果将 data 作为一个函数返回一个对象， 那么每一个实例的 data 属性都是独立的，不会相互影响了。 vue-cli项目中src目录每个文件夹和文件的用法？12345678910src assets | 静态资源 （图片、js、css）components | 非路由组件views | 路由组件router | 路由配置store | vuex（仓库）App.vue | 挂载的第一个组件main.js | 全局的文件index.html &#x3D;&gt; main.js &#x3D;&gt; App.vue 你们vue项目是打包了一个js文件，一个css文件，还是有多个文件？ 1234 根据vue-cli脚手架规范，一个js文件，一个CSS文件。 在打包之前 1.代理的url 2.build assetsPublicPath: &#39;.&#x2F;&#39; watch和computed差异12345678computed ： 计算属性 1. 计算属性是由data中的已知值，得到一个新的值 2. 性能不好 3. 别人变化影响我自己 watch : 监听数据的变化 1. 监听data中的数据 2. 我的变化影响别人 Vue 中 插件使用1231. 下载 npm install xxx2. 引入 import xx from &#39;xxxx&#39; Vue.use(xxx)3. 配置 &lt;xx v-model&#x3D;&#39;xx&#39; select&#x3D;&#39;xx&#39;&gt;&lt;&#x2F;xx&gt; vue 中 key 的作用 总结：1234key的作用主要是为了高效的更新虚拟dom 没有加key，diff默认算法的问题（虚拟dom） 1. 如果节点类型不同，直接干掉前面所有的节点，再创建 路由模式1231.Hash: 使用URL的hash值来作为路由。支持所有浏览器。2.History: 以来HTML5 History API 和服务器配置3. Abstract： 支持所有javascript运行模式。如果发现没有浏览器的API，路由会自动强制进入这个模式。 axios封装12345671.在项目中新建一个axios.js文件，放在你自己的文件夹下2.在axios.js文件中引入axios和qs包3.在axios.js中引入其他需要的包4.将axios的默认配置写上5.然后开始对axios的get，post请求进行封装6.global.js文件，里面放一些全局变量，比如请求前缀等等 Vue导航守卫的钩子函数全局守卫1231.router.beforeEach：全局前置守卫，进入路由之前2.router.beforeResolve：全局解析守卫，在beforeRouteEnter调用之后调用3.router.afterEach：全局后置钩子，进入路由之后 路由组件内的守卫1231.beforeRouteEnter()：进入路由前2.beforeRouteUpdate()：路由复用同一个组件时3.beforeRouteLeave()：离开当前路由时 箭头函数与普通函数的区别123- 内部没有arguments- 内部没有this- 不能作为构造器 常用系统指令1v-if v-show v-model v-bind v-for","tags":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}],"categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"}]},{"title":"css","date":"2017-08-06T16:00:00.000Z","path":"wiki/css/","text":"让一个DIV垂直水平局中 使用css方法 12345678&#x2F;&#x2F;父盒子设置：display: table-cell;text-all: center;vertical-align: middle;div设置：display: inline-block;vertical-align: middle; 使用css3 transform 12345678父盒子设置：display: relativediv设置：transform: translater(-50%,-50%);position: absolute;top: 50%;left: 50%; css引入方式 行内式 内联式 外链式 导入式 css选择器 标签选择器123li&#123; color: red; &#125; 属性选择器12345678/* 把包含标题（title）的所有元素变为红色，可以写作： */*[title] &#123;color:red;&#125;/* 只对有 href 属性的锚（a 元素）应用样式 */a[href] &#123;color:red;&#125;/* 将同时有 href 和 title 属性的 HTML 超链接的文本设置为红色 */a[href][title] &#123;color:red;&#125; id选择器123#two&#123; color: yellow;&#125; 类选择器123.class&#123; color:red;&#125; 并集选择器123 li,.ji&#123;color: red;&#125; 交集选择器123li.ji&#123;color: red; &#125; 后代选择器123div .ji&#123;color: red;&#125; 子代选择器123div&gt;ul&gt;.ji&#123; color: red; &#125; 清除浮动的方法 12341.给父级元素单独定义高度2.在标签结尾处加空div标签 clear:both3.父级div定义 overflow:hidden4.使用伪类元素 flex常用属性父级元素属性（有‘√’为常用属性）12345678910111213141516171819202122display: flex; justify-content: 子元素水平排列方式 center 居中 √ space-between 两端对齐 √ space-around 子元素拉伸分布 √ flex-start 居左 flex-end 居右 align-items: 子元素垂直排列 center 居中 √ flex-start 开始 flex-end 底部 align-content: 多行的时候，垂直排列 center 居中 flex-direction: 排列方式 row 横向排列 row-reverse 横向翻过排列 column 纵向排列 column-reverse 纵向翻过排列 flex-wrap: 子元素是否在一行显示 no-wrap 不换行 wrap 换行flex-flow: &lt;flex-direction&gt; &lt;flex-wrap&gt; 子级身上属性123456789flex: 1; 1 指的是一个系数 *子元素在划分父元素宽度的时候，先刨除固定宽度 flex-grow:1; 定义子元素放大比例 0默认值 align-self: 其实就是用来覆盖父级align-items 垂直排列 center 居中 √ flex-start 开始 flex-end 底部 order: 规定子元素顺序，排序(数值越小，越靠前) 默认值：0 justify-content属性 水平属性align-items属性 垂直属性参考资料 html中文网","tags":[],"categories":[{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"},{"name":"css基础知识","slug":"css/css基础知识","permalink":"http://yoursite.com/categories/css/css%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}]}],"categories":[{"name":"vue","slug":"vue","permalink":"http://yoursite.com/categories/vue/"},{"name":"promise","slug":"promise","permalink":"http://yoursite.com/categories/promise/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/categories/js/"},{"name":"css","slug":"css","permalink":"http://yoursite.com/categories/css/"},{"name":"css基础知识","slug":"css/css基础知识","permalink":"http://yoursite.com/categories/css/css%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"mvvm","slug":"mvvm","permalink":"http://yoursite.com/tags/mvvm/"},{"name":"promise","slug":"promise","permalink":"http://yoursite.com/tags/promise/"},{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"},{"name":"闭包","slug":"闭包","permalink":"http://yoursite.com/tags/%E9%97%AD%E5%8C%85/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"vue","slug":"vue","permalink":"http://yoursite.com/tags/vue/"}]}