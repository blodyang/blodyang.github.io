<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-02T09:00:03.944Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue</title>
    <link href="http://yoursite.com/wiki/vue/"/>
    <id>http://yoursite.com/wiki/vue/</id>
    <published>2020-08-02T08:58:18.000Z</published>
    <updated>2020-08-02T09:00:03.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="v-if-v-show区别"><a href="#v-if-v-show区别" class="headerlink" title="v-if  v-show区别"></a>v-if  v-show区别</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">v-if更高的切换开销，v-show更高的渲染开销，</span><br><span class="line">频繁切换 v-show比较好，运行时条件不太可能改变 v-if比较好</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">v-if监听组件的销毁与创建    v-if惰性，初始条件为假，什么也不做，只到条件第一次为真时候，才会开始条件渲染</span><br><span class="line">v-show 不管初始条件是什么，元素总是被渲染，并且只是简单的</span><br><span class="line">基于css进行切换</span><br></pre></td></tr></table></figure><h3 id="Vue生命周期"><a href="#Vue生命周期" class="headerlink" title="Vue生命周期"></a>Vue生命周期</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">（2+） beforeCreate created beforeMount mounted beforeUpdate updated beforeDestroy destroyed </span><br><span class="line">-----使用了 keep-alive 就会多2个生命周期： activated deactivated </span><br><span class="line"></span><br><span class="line">二、生命周期的理解 总共分为：8个阶段 创建前&#x2F;后： </span><br><span class="line"></span><br><span class="line">beforeCreate ：vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。 </span><br><span class="line">created ： vue实例的数据对象data有了，但是$el还是没有 </span><br><span class="line">载入前&#x2F;后 beforeMount : vue实例的$el和data都初始化了,但还是挂载之前为虚拟dom节点，data.msg还未替换。 </span><br><span class="line">mounted : vue实例挂载完成,data.msg成功渲染的 </span><br><span class="line">更新前&#x2F;后 当data变化时，会触发：beforeUpdate、updated </span><br><span class="line">销毁前&#x2F;后 当销毁的时候，会触发： beforeDestroy、destroyed </span><br><span class="line"></span><br><span class="line">三、DOM 渲染在哪个周期中就已经完成 ： mounted</span><br></pre></td></tr></table></figure><h3 id="组件传值"><a href="#组件传值" class="headerlink" title="组件传值"></a>组件传值</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">父传子 props</span><br><span class="line">字传父  $emit传递一个事件，父组件监听事件</span><br><span class="line">兄弟传值  bus传值  $emit触发  $on监听</span><br></pre></td></tr></table></figure><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">是什么？ </span><br><span class="line"></span><br><span class="line">内置组件，能在组件切换过程中将状态保存在内存中，防止重复渲染dom</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">keep-alive不会再dom树中渲染</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Vue-中的data为什么必须是一个函数"><a href="#Vue-中的data为什么必须是一个函数" class="headerlink" title="Vue 中的data为什么必须是一个函数"></a>Vue 中的data为什么必须是一个函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Vue 组件 data 为什么必须是函数    </span><br><span class="line">不用脚手架 vue.js new Vue(&#123; el:&quot;#app&quot;, template:xxx data: &#123; &#125; &#125;)   </span><br><span class="line">脚手架 组件 data 为什么必须是函数? 因为 JS 本身的特性带来的，   </span><br><span class="line">如果 data 是一个对象，那么由于对象本身属于引用类型，   </span><br><span class="line">当我们修改其中的一个属性时，   </span><br><span class="line">会影响到所有 Vue 实例的数据。如果将 data 作为一个函数返回一个对象，   </span><br><span class="line">那么每一个实例的 data 属性都是独立的，不会相互影响了。</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="vue-cli项目中src目录每个文件夹和文件的用法？"><a href="#vue-cli项目中src目录每个文件夹和文件的用法？" class="headerlink" title="vue-cli项目中src目录每个文件夹和文件的用法？"></a>vue-cli项目中src目录每个文件夹和文件的用法？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">src assets           |     静态资源 （图片、js、css）</span><br><span class="line">components           |     非路由组件</span><br><span class="line">views                |      路由组件</span><br><span class="line">router               |      路由配置</span><br><span class="line">store                |      vuex（仓库）</span><br><span class="line">App.vue              |      挂载的第一个组件</span><br><span class="line">main.js              |      全局的文件</span><br><span class="line"></span><br><span class="line">index.html &#x3D;&gt; main.js  &#x3D;&gt; App.vue</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="你们vue项目是打包了一个js文件，一个css文件，还是有多个文件？"><a href="#你们vue项目是打包了一个js文件，一个css文件，还是有多个文件？" class="headerlink" title="你们vue项目是打包了一个js文件，一个css文件，还是有多个文件？"></a>你们vue项目是打包了一个js文件，一个css文件，还是有多个文件？</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 根据vue-cli脚手架规范，一个js文件，一个CSS文件。 </span><br><span class="line">在打包之前</span><br><span class="line"> 1.代理的url </span><br><span class="line">2.build assetsPublicPath: &#39;.&#x2F;&#39;</span><br></pre></td></tr></table></figure><h3 id="watch和computed差异"><a href="#watch和computed差异" class="headerlink" title="watch和computed差异"></a>watch和computed差异</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">computed ： 计算属性 1. 计算属性是由data中的已知值，得到一个新的值    </span><br><span class="line">2. 性能不好   </span><br><span class="line">3. 别人变化影响我自己   </span><br><span class="line"></span><br><span class="line"> watch : 监听数据的变化   </span><br><span class="line"> 1. 监听data中的数据   </span><br><span class="line"> 2. 我的变化影响别人</span><br><span class="line"> </span><br></pre></td></tr></table></figure><h3 id="Vue-中-插件使用"><a href="#Vue-中-插件使用" class="headerlink" title="Vue 中 插件使用"></a>Vue 中 插件使用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 下载 npm install xxx</span><br><span class="line">2. 引入 import xx from &#39;xxxx&#39; Vue.use(xxx)</span><br><span class="line">3. 配置 &lt;xx v-model&#x3D;&#39;xx&#39; select&#x3D;&#39;xx&#39;&gt;&lt;&#x2F;xx&gt;</span><br></pre></td></tr></table></figure><h3 id="vue-中-key-的作用-总结："><a href="#vue-中-key-的作用-总结：" class="headerlink" title="vue 中 key 的作用 总结："></a>vue 中 key 的作用 总结：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">key的作用主要是为了高效的更新虚拟dom 没有加key，diff默认算法的问题（虚拟dom） </span><br><span class="line"></span><br><span class="line">1. 如果节点类型不同，直接干掉前面所有的节点，再创建</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="路由模式"><a href="#路由模式" class="headerlink" title="路由模式"></a>路由模式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.Hash:      使用URL的hash值来作为路由。支持所有浏览器。</span><br><span class="line">2.History:   以来HTML5 History API 和服务器配置</span><br><span class="line">3.　Abstract： 支持所有javascript运行模式。如果发现没有浏览器的API，路由会自动强制进入这个模式。</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;v-if-v-show区别&quot;&gt;&lt;a href=&quot;#v-if-v-show区别&quot; class=&quot;headerlink&quot; title=&quot;v-if  v-show区别&quot;&gt;&lt;/a&gt;v-if  v-show区别&lt;/h3&gt;&lt;figure class=&quot;highlight pl
      
    
    </summary>
    
    
      <category term="vue" scheme="http://yoursite.com/categories/vue/"/>
    
    
      <category term="vue" scheme="http://yoursite.com/tags/vue/"/>
    
      <category term="生命周期" scheme="http://yoursite.com/tags/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    
  </entry>
  
</feed>
